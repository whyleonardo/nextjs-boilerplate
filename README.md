# Next.js Production Boilerplate

A minimal, production-ready Next.js starter with modern tooling and authentication wired up — no demo content, ready to build on.

## Stack

- **Next.js 16** (App Router, React 19, Turbopack)
- **TypeScript** + **Tailwind CSS v4**
- **bun** package manager
- **@t3-oss/env-nextjs** type-safe environment variables
- **Biome** + **ultracite** for linting/formatting
- **shadcn/ui** component library
- **better-auth** authentication (email/password, extendable)
- **Drizzle ORM** + **PostgreSQL**
- **oRPC** type-safe API layer
- **TanStack Query v5** data fetching
- **TanStack DB** client-side collections
- **Zustand** global state (with persist)
- **React Hook Form** + **Zod** validation

## Quick Start

```bash
# Clone and install
git clone https://github.com/whyleonardo/nextjs-boilerplate.git
cd nextjs-boilerplate
bun install

# Set up environment
cp .env.example .env.local
# Edit .env.local — set BETTER_AUTH_SECRET to a random 32+ char string

# Start PostgreSQL
docker compose up -d

# Push database schema
bun run db:push

# Start dev server
bun run dev
```

Visit [http://localhost:3000](http://localhost:3000)

## Project Structure

```
src/
  app/                          # Next.js App Router
    (auth)/                     # Auth pages (sign-in, sign-up)
    (dashboard)/dashboard/      # Protected route example
    api/
      auth/[...all]/            # better-auth API
      rpc/[[...rest]]/          # oRPC API
  features/                     # Feature-based modules
    auth/components/            # Client components (forms, etc.)
    <name>/
      contracts.ts              # API contract (schemas + HTTP metadata)
      procedures/               # oRPC procedure implementations
  components/                   # Shared components
    ui/                         # shadcn/ui primitives
    auth/                       # Auth components (user-button)
  lib/                          # Client utilities
    auth/
      client.ts                 # better-auth React client
      session.ts                # Server-side session helpers
    orpc/                       # oRPC client + server caller
    query/                      # TanStack Query hydration
  server/                       # Server-only code
    auth/                       # better-auth config
    db/                         # Drizzle client + schema
    rpc/                        # oRPC router (wires feature slices together)
  store/                        # Zustand stores
```

## Environment Variables

Environment variables are validated at build time using `@t3-oss/env-nextjs` and Zod schemas.

All environment variable definitions live in `src/env.ts`:
- **Server variables**: Only accessible server-side (e.g., `DATABASE_URL`, `BETTER_AUTH_SECRET`)
- **Client variables**: Must be prefixed with `NEXT_PUBLIC_` (e.g., `NEXT_PUBLIC_APP_URL`)

**Adding a new environment variable:**
1. Add to `.env.example` and `.env.local`
2. Add schema to `src/env.ts` (server or client section)
3. Add to `runtimeEnv` object in `src/env.ts`

Import and use: `import { env } from "@/env"`

## Authentication

Server-side route guards live in Server Components — no middleware.

**Protect a page:**
```tsx
import { requireSession } from "@/lib/auth/session";

export default async function ProtectedPage() {
  const { user } = await requireSession(); // Redirects to /sign-in if not authenticated
  return <div>Hello {user.email}</div>;
}
```

**Redirect authenticated users away from auth pages:**
```tsx
import { requireGuest } from "@/lib/auth/session";

export default async function AuthLayout({ children }) {
  await requireGuest(); // Redirects to /dashboard if already signed in
  return <div>{children}</div>;
}
```

## Database

```bash
bun run db:generate   # Generate migration from schema changes
bun run db:migrate    # Run migrations
bun run db:push       # Push schema to DB (dev only)
bun run db:studio     # Open Drizzle Studio
```

Schema files live in `src/server/db/schema/`. The `auth.ts` schema is auto-generated by better-auth.

## API (oRPC)

The API layer uses a **contract-first** pattern. Each feature owns its contract (schema + HTTP metadata) and its procedure implementations. The central router in `src/server/rpc/index.ts` only wires features together.

### File layout (follow the `todo` feature as the reference)

```
src/features/<name>/
  contracts.ts          # API shape: schemas + HTTP route metadata (no logic)
  procedures/
    <procedure>.ts      # One file per procedure
    index.ts            # Assembles and exports the router slice
```

### 1. Define the contract

```ts
// src/features/todo/contracts.ts
import { oc } from "@orpc/contract";
import { z } from "zod";

export const TodoSchema = z.object({
  id: z.string(),
  title: z.string(),
});

export type Todo = z.infer<typeof TodoSchema>;

export const todoContract = {
  list: oc
    .route({ method: "GET", path: "/todos", summary: "List all todos" })
    .output(z.array(TodoSchema)),

  create: oc
    .route({ method: "POST", path: "/todos", summary: "Create a todo" })
    .input(z.object({ title: z.string().min(1).max(255) }))
    .output(TodoSchema),
};
```

### 2. Implement each procedure in its own file

```ts
// src/features/todo/procedures/list.ts
import { implement } from "@orpc/server";
import { todoContract } from "@/features/todo/contracts";
import { authMiddleware } from "@/server/rpc/middleware";

const os = implement(todoContract);

export const listTodos = os.list.use(authMiddleware).handler(() => {
  return []; // replace with a real query
});
```

```ts
// src/features/todo/procedures/create.ts
import { implement } from "@orpc/server";
import { type Todo, todoContract } from "@/features/todo/contracts";
import { authMiddleware } from "@/server/rpc/middleware";

const os = implement(todoContract);

export const createTodo = os.create.use(authMiddleware).handler(({ input }) => {
  const todo: Todo = { id: crypto.randomUUID(), title: input.title };
  return todo;
});
```

### 3. Assemble the feature slice

```ts
// src/features/todo/procedures/index.ts
import { listTodos } from "./list";
import { createTodo } from "./create";

export const todo = {
  list: listTodos,
  create: createTodo,
};
```

### 4. Register the slice in the router

```ts
// src/server/rpc/index.ts
import { todo } from "@/features/todo/procedures";

export const router = {
  todo,
};

export type AppRouter = typeof router;
```

### Middleware

Two procedure bases are available from `src/server/rpc/middleware.ts`:

| Export | When to use |
|---|---|
| `publicProcedure` | No auth required |
| `authMiddleware` | Use with `implement()` — gates the handler behind a valid session |
| `protectedProcedure` | Builder-style alternative to `authMiddleware` |

### Calling procedures from the client

```tsx
"use client";
import { orpc } from "@/lib/orpc/client";
import { useQuery, useMutation } from "@tanstack/react-query";

export function Todos() {
  const { data } = useQuery(orpc.todo.list.queryOptions());

  const create = useMutation(orpc.todo.create.mutationOptions());

  return (
    <div>
      {data?.map(t => <p key={t.id}>{t.title}</p>)}
      <button onClick={() => create.mutate({ title: "New todo" })}>Add</button>
    </div>
  );
}
```

### Calling procedures from Server Components

```tsx
// No HTTP round-trip — calls the router directly on the server
import "@/lib/orpc/server";

export default async function TodosPage() {
  const todos = await globalThis.$client.todo.list();
  return <ul>{todos.map(t => <li key={t.id}>{t.title}</li>)}</ul>;
}
```

## OpenAPI Documentation

The API automatically generates OpenAPI 3.x specification from your oRPC router.

**Interactive API documentation (Scalar UI):**
- Development: `http://localhost:3000/api`
- Production: `https://your-domain.com/api`
- Or visit `/api/openapi` in a browser (auto-detects HTML preference)

**Raw OpenAPI spec (JSON):**
- `/api/openapi` — JSON specification (default for API clients)
- `/api/openapi?format=json` — Explicit JSON format

**Use the spec with:**
- **Postman**: Import `/api/openapi` URL
- **API clients**: Generate SDKs using [openapi-generator](https://github.com/OpenAPITools/openapi-generator)
- **Custom tools**: Consume the OpenAPI JSON directly

The spec is auto-generated from your Zod schemas and contract definitions in `src/features/`.

## Scripts

```bash
bun run dev           # Start dev server
bun run build         # Production build
bun run start         # Start production server
bun run lint          # Biome check (via ultracite)
bun run fix           # Biome fix (via ultracite)
```

## What's Included

- Email/password authentication (extendable to OAuth, magic links, etc.)
- Server-side session management
- Protected route example (`/dashboard`)
- Auth pages with client-side forms
- Type-safe API client (oRPC + TanStack Query)
- Database migrations + Drizzle Studio
- shadcn/ui components (button, card, input, form, dropdown, avatar, etc.)
- Minimal Zustand store with localStorage persistence
- Docker Compose PostgreSQL setup

## What's NOT Included

This is infrastructure, not a demo app. No landing page, no todo list, no dashboard layout. Build your own features on top.

## License

MIT
